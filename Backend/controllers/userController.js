import User from "../models/userModel.js";
import bcrypt from "bcryptjs"
import generateTokenAndSetCookie from "../utils/helpers/generateTokenAndSetCookie.js";
// import express from "express";


const getUserProfile = async (req, res) => {
    const { username } = req.params;

    try {
        const user = await User.findOne({ username }).select("-password").select("-updatedAt")
        if (!user) return res.status(400).json({error: "User not found."})
        res.status(200).json(user)

    } catch (error) {
        res.status(500).json({ error: err.message });
        console.log("Error in updateUser: ", err.message);

    }
}

const signupUser = async (req, res) => {
    // res.send("Do")
    try {
        const { name, email, username, password } = req.body;
        const user = await User.findOne({ $or: [{ email }, { username }] })//This will check whether the user is registered or not {::more specifically it will check for any email or username of the user in the db::}

        if (user) {
            res.status(400).json({ error: "User already exists" })//If user already registered
        }

        //hashing password
        const salt = await bcrypt.genSalt(10)
        const hashedPassword = await bcrypt.hash(password, salt)

        //creating new USER
        const newUser = new User({
            name,
            email,
            username,
            password: hashedPassword,
        });
        //saving user and sending response
        await newUser.save();

        if (newUser) {
            generateTokenAndSetCookie(newUser._id, res);//this file is used to generate token and cookie
  
            res.status(201).json({
                _id: newUser._id,//the id is auto generated by mongodb
                name: newUser.name,
                email: newUser.email,
                username: newUser.username,
            })
        }
        // res.status(200).json({ message: "User created successfully" })
        else {
            res.status(400).json({ error: "Invalid User data" })
        }

    } catch (err) {
        res.status(500).json({ error: err.message })
        console.log("Error in signupUser:", err.message)

    }
}

const loginUser = async (req, res) => {
    try {
        const { username, password } = req.body;
        const user = await User.findOne({ username });
        const isPasswordCorrect = await bcrypt.compare(password, user?.password || "");
        //here if the user name not found then it will give a strange error bcz bycrpt cannot compare a string (i.e. passoword) from a null (i.e. user?.password)        
        // So to solve this we have used '||' , therefore , if the user not found then bcrypt will compare pass with an empty block
        //and why ? placed betwee user , password ,, bcz if user is empty then how will it search for pass , so ? is added

        if (!user || !isPasswordCorrect) { return res.status(400).json({ error: "Invalid username or password" }); }

        generateTokenAndSetCookie(user._id, res)

        res.status(200).json({
            _id: user._id,
            name: user.name,
            username: user.username,
            email: user.email,
        });


    } catch (error) {
        res.status(500).json({ error: error.message })
        console.log("Error in loging user", error.message)

    }
}

const logoutUser = (req, res) => {
    try {
        res.cookie("jwt", "", { maxAge: 1 })//after 1 ms it gonna cleared out
        res.status(200).json({ message: "User logged out successfully" })

    } catch (error) {
        res.status(500).json({ error: error.message })
        console.log("Error Occured", error.message)

    }
}

const followUnfollowUser = async (req, res) => {
    try {
        // console.log("Received request to follow/unfollow user:", req.params.id);

        const { id } = req.params;
        const userToModify = await User.findById(id);//this is the person that we(app's user) gonna follow or unfollow
        const currentUser = await User.findById(req.user._id)//here current USER will be us 
        if (id === req.user._id.toString()) { return res.status(400).json({ error: "You cannot follow / unfollow yourself!" }); }//By using .toString you willnot be able to follow/unfollow yourself.......But if you remove it you can follow/unfollow yourself 

        if (!userToModify || !currentUser) { return res.status(400).json({ error: "User not found." }) }

        const isFollowing = currentUser.following.includes(id);

        if (isFollowing) {
            //Unfollow User

            //Modify current user  following, modify followers of userToModify

            await User.findByIdAndUpdate(id, { $pull: { followers: req.user._id } })//Same, id of the person current user followed will also be removed from here

            await User.findByIdAndUpdate(req.user._id, { $pull: { following: id } })//this will remove current user id from the person that he/she followed previously...

            res.status(200).json({ message: "User unfollowed successfully." })
            // console.log("error",error)

        }
        else {
            //Follow User

            //Modify current user   
            await User.findByIdAndUpdate(id, { $push: { followers: req.user._id } })
            await User.findByIdAndUpdate(req.user._id, { $push: { following: id } })

            res.status(200).json({ message: "User followed successfully." })

        }


    } catch (error) {
        res.status(500).json({ error: error.message })
        console.log("Error in followUnfollow User", error.message)

    }
}

const updateUser = async (req, res) => {
    const { name, email, password, username, profilePic, bio } = req.body
    const userId = req.user._id
    try {
        let user = await User.findById(userId);
        if (!user) return res.status(400).json({ error: "User not found.." })

        if (req.params.id !== userId.toString()) return res.status(400).json({ error: "You cannot update other user's profile" });



        if (password) {

            const salt = await bcrypt.genSalt(10);
            const hashedPassword = await bcrypt.hash(password, salt);

            user.password = hashedPassword

        }
        user.name = name || user.name;
        user.email = email || user.email;
        user.username = username || user.username;
        user.bio = bio || user.bio;
        user.profilePic = profilePic || user.profilePic;

        user = await user.save();
        res.status(200).json({ message: "Profile Updated successfully", user })


    } catch (error) {
        res.status(500).json({ error: error.message })
        console.log("Error in update User", error.message)

    }
}

// const updateUser = async (req, res) => {
// 	const { name, email, username, password, bio } = req.body;
// 	let { profilePic } = req.body;

// 	const userId = req.user._id;
// 	try {
// 		let user = await User.findById(userId);
// 		if (!user) return res.status(400).json({ error: "User not found" });

// 		if (req.params.id !== userId.toString())
// 			return res.status(400).json({ error: "You cannot update other user's profile" });

// 		if (password) {
// 			const salt = await bcrypt.genSalt(10);
// 			const hashedPassword = await bcrypt.hash(password, salt);
// 			user.password = hashedPassword;
// 		}

// 		if (profilePic) {
// 			if (user.profilePic) {
// 				await cloudinary.uploader.destroy(user.profilePic.split("/").pop().split(".")[0]);
// 			}

// 			const uploadedResponse = await cloudinary.uploader.upload(profilePic);
// 			profilePic = uploadedResponse.secure_url;
// 		}

// 		user.name = name || user.name;
// 		user.email = email || user.email;
// 		user.username = username || user.username;
// 		user.profilePic = profilePic || user.profilePic;
// 		user.bio = bio || user.bio;

// 		user = await user.save();

// 		// Find all posts that this user replied and update username and userProfilePic fields
// 		await Post.updateMany(
// 			{ "replies.userId": userId },
// 			{
// 				$set: {
// 					"replies.$[reply].username": user.username,
// 					"replies.$[reply].userProfilePic": user.profilePic,
// 				},
// 			},
// 			{ arrayFilters: [{ "reply.userId": userId }] }
// 		);

// 		// password should be null in response
// 		user.password = null;

// 		res.status(200).json(user);
// 	} catch (err) {
// 		res.status(500).json({ error: err.message });
// 		console.log("Error in updateUser: ", err.message);
// 	}
// };



export { signupUser, loginUser, logoutUser, followUnfollowUser, updateUser, getUserProfile }